\chapter{Caso studio}
\label{chap:real_case}

\section{Presentazione}
\label{sec:presentation}

Dopo aver illustrato nei capitoli precedenti le principali vulnerabilità legate alla
gestione della memoria e le relative tecniche di mitigazione, questo capitolo
presenta un caso studio pratico, volto a dimostrare come i concetti teorici possano
essere applicati concretamente ad un progetto reale.

L'obiettivo iniziale era quello di selezionare un progetto open source scritto in
C o C++, in modo da analizzarlo e rafforzarne la memory safety mediante
strumenti statici e dinamici. Tuttavia, durante la fase di selezione, è emerso un
problema ricorrente: i progetti realmente utilizzati in produzione risultavano
già abbastanza robusti e testati, rendendo poco significativa l'analisi; mentre,
all'estremo opposto, i progetti "educational" erano spesso troppo semplificati e
artificiali.

Per superare questo dilemma, si è optato per un approccio intermedio: la
generazione di un progetto realistico ma deliberatamente vulnerabile. A tal fine,
è stato impiegato \textit{GitHub Copilot}\footnote{\url{https://github.com/features/copilot}}
in modalità \textit{Agent}, richiedendo esplicitamente la creazione di un'applicazione
plausibile, scritta in C, che includesse vulnerabilità comuni di memory safety a
fini educativi e dimostrativi. Per trasparenza, il prompt utilizzato è
disponibile in appendice (~\autoref{appendix:attachment}).

Il progetto risultante è un \textbf{file tracker}, ovvero un'applicazione a riga
di comando che monitora una directory specificata, rilevando in tempo reale la
creazione, modifica e cancellazione di file. Il programma supporta opzioni
avanzate per il filtraggio dei file, la configurazione dell'intervallo di polling,
il logging su file e la modalità verbosa.

Nonostante la sua apparente semplicità, il codice è strutturato in più moduli e include
numerosi bug intenzionali. Nella ~\autoref{tab:tracker_vulnerabilities} è riportato
un elenco delle vulnerabilità identificate, con le relative posizioni nel codice.

\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|} % |p{6cm}|}
    \hline
    \textbf{Bug/Vulnerabilità} & \textbf{Posizione}                     \\ % & \textbf{Spiegazione}
    \hline
    Out-of-Bounds Write        & \texttt{main.c:27}, \texttt{main.c:42} \\ % & Se i pattern sono più di 5 o lunghi più di 63 caratteri, la copia della stringa va oltre i limiti
    \hline
    Use After Free             & \texttt{main.c:127}                    \\ % & La variabile \texttt{tracker} viene usata dopo la sua distruzione
    \hline
    Memory Leak                & \texttt{utils.c:14-18}                 \\ % & Se \texttt{malloc()} di \texttt{info->path} fallisce, \texttt{info} non viene liberata ma la funzione termina
    \hline
    Out-of-Bounds Read         & \texttt{utils.c:56}                    \\ % & Se il nome del file è più corto dell'estensione con cui viene confrontato, la lettura può uscire dai limiti della stringa
    \hline
    Dangling Pointer           & \texttt{utils.c:72-79}                 \\ % & Nel contesto attuale non particolarmente rilevante, ma in casi di concorrenza, può portare uso di valori errati
    \hline
    Buffer Overflow            & \texttt{tracker\_core.c:14,18}         \\ % & Scrittura di argomenti da linea di comando in buffer limitati
    \hline
    Double Free                & \texttt{tracker\_core.c:45}            \\ % & Evidente doppia deallocazione di \texttt{tracker->monitored\_directory}
    \hline
    Dangling Pointer           & \texttt{tracker\_core.c:56}            \\ % & Dopo la deallocazione, il puntatore \texttt{tracker} dovrebbe essere uguale a \texttt{NULL}
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:81}            \\ % & Copia di stringa in buffer senza controllo della lunghezza
    \hline
    Use After Free             & \texttt{tracker\_core.c:161}           \\ % & Stampa dell'elemento rimosso dopo la sua deallocazione
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:194}           \\ % & Copia di stringa in una matrice di caratteri senza controllo della lunghezza (su entrambe le dimensioni)
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:216}           \\ % & Scrittura di stringa in un buffer troppo piccolo
    \hline
  \end{tabular}
  \caption{Vulnerabilità presenti nel progetto File Tracker}
  \label{tab:tracker_vulnerabilities}
\end{table}

Una lista con spiegazioni dettagliate di ciascuna vulnerabilità è disponibile nel
file \texttt{README.md} del progetto\footnote{Progetto GitHub: \url{https://github.com/Isax03/unsafe-file-tracker}},
che può essere consultato per approfondire le problematiche specifiche.

\begin{quote}
  \textbf{Nota:} È importante sottolineare che, in un contesto reale di progettazione
  ex novo, molte delle vulnerabilità analizzate in questo capitolo avrebbero
  potuto essere evitate scegliendo un linguaggio memory safe già in fase di
  design (~\autoref{sec:linguaggio}).

  Tuttavia, l'approccio adottato in questo caso studio è deliberatamente diverso:
  si è scelto di partire da un'applicazione scritta in C, linguaggio
  storicamente vulnerabile ma ancora ampiamente utilizzato, per illustrare concretamente
  l'efficacia (e le limitazioni) degli strumenti di analisi e delle tecniche di mitigazione
  nel contesto di un progetto esistente. Questo consente di simulare un caso
  realistico di refactoring e messa in sicurezza di software legacy, situazione frequente
  nel mondo industriale.
\end{quote}

Nel corso del capitolo vengono illustrati:
\begin{itemize}
  \item I principali difetti rilevati tramite analisi statica e dinamica

  \item Le correzioni apportate per eliminare le vulnerabilità

  \item Il confronto tra l'esecuzione pre e post-mitigazione, utilizzando
    strumenti di verifica
\end{itemize}

Questo caso studio rappresenta quindi una dimostrazione concreta dell'approccio
proposto nella tesi: identificare, analizzare e mitigare vulnerabilità di
memoria lungo il ciclo di vita del software, anche in assenza di exploit attivi.

\begin{quote}
  \textbf{Dettagli d'ambiente:} Il progetto è stato analizzato, compilato ed eseguito
  su un sistema \textit{Linux} (Ubuntu 24.04.2 LTS). Di conseguenza, tutti i risultati
  presentati fanno riferimento a tale ambiente.

  I tool utilizzati sono generalmente disponibili anche su altri sistemi operativi,
  inclusi altri ambienti Linux, macOS e in parte Windows. Tuttavia, non si garantisce
  il corretto funzionamento né la piena compatibilità su piattaforme diverse,
  poiché potrebbero sussistere differenze nei compilatori, nelle librerie di sistema
  o nei meccanismi di gestione della memoria che influenzano l'efficacia degli strumenti
  e la riproducibilità dei risultati.
\end{quote}

\input{chapters/real_case/initial_analysis.tex}
\input{chapters/real_case/sdlc_phases.tex}
\input{chapters/real_case/comparison.tex}