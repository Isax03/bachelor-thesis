\section{Analisi preliminare}
\label{sec:initial_analysis}

Dal momento che questo caso studio si basa su un'applicazione già scritta e funzionante,
la prima fase non sarà quella di riscrivere il codice seguendo le best practice
e usando librerie che aggiungono controlli di sicurezza, ma piuttosto quella di analizzare
il codice presente nel progetto, identificare le vulnerabilità e valutare l'efficacia
degli strumenti utilizzati per la loro individuazione.

\subsection*{Analisi statica}
Seguendo l'ordine in cui sono state introdotte le tecniche di mitigazione nel ~\autoref{cha:sdlc},
la prima fase di analisi è quella statica, che analizza il codice sorgente senza
effettivamente eseguirlo.

\paragraph{Criteri di selezione degli strumenti}
I tool di analisi sono stati scelti a partire dalla lista proposta dal \textit{National
Institute of Standards and Technology} (NIST)\footnote{Source Code Security
Analyzers: \url{https://www.nist.gov/itl/ssd/software-quality-group/source-code-security-analyzers}}
che propone quasi 90 strumenti di analisi statica, in una tabella che comprende i
linguaggi supportati, le funzionalità offerte, la disponibilità (gratuita o meno)
e la data dell'ultimo aggiornamento. Grazie a queste informazioni, è stato possibile
restringere la scelta degli strumenti da utilizzare, usando i seguenti criteri:
\begin{itemize}
  \item \textbf{Linguaggio supportato}: rimuovendo dalla lista gli strumenti che
    non supportano il linguaggio C, si è ottenuta una lista di circa 50 tool

  \item \textbf{Disponibilità gratuita}: dal momento che si tratta di un caso studio
    didattico, si è scelto di utilizzare solo strumenti gratuiti, eliminando dalla
    lista quelli a pagamento o con licenza commerciale. Questo ha ridotto
    ulteriormente la lista a 16 strumenti.

  \item \textbf{Data dell'ultimo aggiornamento}: per garantire l'affidabilità degli
    strumenti, si è scelto di considerare solo quelli aggiornati dal 2010 in poi.
    Questo ha dimezzato la lista a otto strumenti.

  \item \textbf{Focus sulla memory safety}: sono stati infine esclusi gli strumenti
    che non avevano la sicurezza della memoria tra i principali obiettivi e quelli
    troppo general purpose.
\end{itemize}

Questa scrematura ha portato a una lista finale di tre strumenti: \textbf{CppCheck},
un analizzatore statico di codice C/C++ focalizzato su errori di programmazione e
vulnerabilità di sicurezza; \textbf{Clang Static Analyzer}, parte del progetto
Clang che fornisce funzionalità avanzate per il rilevamento di errori e
vulnerabilità; e \textbf{Frama-C}, un analizzatore statico di codice C che si concentra
sulla sicurezza della memoria e sulla rilevazione di vulnerabilità comuni.

\medskip
\subsubsection*{\small CppCheck\footnote{Sito: \url{https://cppcheck.sourceforge.io/}}}
L'analizzatore \texttt{cppcheck} è il primo strumento che è stato utilizzato per
l'analisi statica del codice sorgente. Esso è in grado di rilevare errori di programmazione,
vulnerabilità di sicurezza e altri problemi nel codice C/C++.

\noindent
Lo strumento è stato eseguito con il seguente comando: \begin{lstlisting}[language=bash, numbers=none]
cppcheck --enable=warning --inconclusive --std=c11 *.c
\end{lstlisting}
Il comando specifica di abilitare i warning e di considerare anche i casi in cui
non è possibile determinare con certezza se un codice sia corretto o meno (\texttt{--inconclusive}),
e di utilizzare lo standard C11 per l'analisi.

L'analisi ha prodotto risultati limitati. CppCheck ha identificato
esclusivamente un potenziale memory leak, fallendo nel rilevare le vulnerabilità
più critiche come il buffer overflow e il double free presenti nel codice.

\begin{lstlisting}[language={}, numbers=none]
utils.c:17:9 error: Memory leak: info [memleak]
  return NULL;
  ^
\end{lstlisting}

Questo risultato è stato inaspettato, poiché ci si aspettava che lo strumento rilevasse
almeno parte delle vulnerabilità presenti nel codice, come ad esempio il rischio
di buffer overflow o l'evidente double free presente nel file \texttt{tracker\_core.c}.
Per questo motivo, è consigliato utilizzare più strumenti di analisi statica nei
progetti reali, per ottenere risultati più completi e affidabili.

\medskip

\subsubsection*{\small Clang\footnote{Sito: \url{https://clang.llvm.org/}}}
Un altro strumento di analisi statica utilizzato è \texttt{clang}, che è un compilatore
con funzionalità di analisi statica integrate. Esso, come \texttt{cppcheck}, è in
grado di rilevare errori di programmazione e vulnerabilità di sicurezza nel codice
C/C++.

Anche in questo caso, lo strumento è stato eseguito da terminale e l'analisi
statica del codice è possibile con i seguente comando: \begin{lstlisting}[language={}, numbers=none]
clang --analyze -Xanalyzer -analyzer-checker=core,security *.c
\end{lstlisting}
Il comando specifica di eseguire l'analisi statica del codice e di abilitare i checker
per la sicurezza e per i \textit{core issue}.

L'analisi ha prodotto risultati più interessanti rispetto a \texttt{cppcheck},
evidenziando diversi problemi nel codice:
\begin{itemize}
  \item \textbf{Funzioni non sicure}: gran parte dell'output del comando evidenzia
    l'uso di funzioni non sicure, in particolare \texttt{strcpy}, \texttt{sprintf}
    e \texttt{fprintf}. In più, \texttt{clang} suggerisce funzioni alternative più
    sicure, come \texttt{strlcpy}, \texttt{sprintf\_s} e \texttt{fprintf\_s}, che
    dovrebbero essere utilizzate per evitare vulnerabilità di buffer overflow.

  \item \textbf{Memory Leak}: viene rilvato lo stesso memory leak già evidenziato
    da \texttt{cppcheck}

  \item \textbf{Double Free}: al contrario di \texttt{cppcheck}, \texttt{clang}
    riesce a rilevare l'ovvio problema di double free presente nel file \texttt{tracker\_core.c}
\end{itemize}

\medskip

\subsubsection*{\small Frama-C\footnote{Sito: \url{https://frama-c.com/}}}
L'ultimo strumento di analisi statica utilizzato sul progetto File Tracker è \texttt{Frama-C},
un analizzatore che mira a combinare più tecniche di analisi, fornite tramite
plugin, per massimizzare l'eliminazione di bug e vulnerabilità nel codice C.

Frama-C è un analizzatore più complesso rispetto ai precedenti, poiché prevede
sia uno strumento che lavora da linea di comando (come gli altri due), sia un'interfaccia
grafica che permette di visualizzare i risultati dell'analisi in modo più interattivo.
In entrambi i casi, l'output richiede più sforzo per essere compreso, poiché i
risultati sono presentati in modo più dettagliato e con terminologia più tecnica.

Avviando l'interfaccia grafica di Frama-C con il comando
\begin{lstlisting}[language=bash, numbers=none]
frama\-c\-gui \-eva *.c
\end{lstlisting}
si ottiene una visualizzazione del codice sorgente con i risultati dell'analisi
evidenziati direttamente sul codice. In questo modo, è possibile navigare tra le
funzioni e i file del progetto, visualizzando i problemi rilevati in modo interattivo.

L'analisi, in questo caso, ha prodotto risultati "peggiori" rispetto agli altri due
strumenti, dal momento che la maggior parte del codice analizzato ha segnalato
un risultati inconcludenti, ovvero che non è stato possibile determinare con certezza
se il codice sia corretto o meno. L'unico bug che Frama-C è riuscito a segnalare
è stato lo use-after-free nelle ultime righe del file \texttt{main.c}.

\bigskip
\noindent
\paragraph{Riepilogo dell'analisi statica}
L'analisi statica del codice sorgente del progetto File Tracker, condotta utilizzando
tre strumenti distinti, ha evidenziato diverse criticità nel codice. Come mostrato
nella ~\autoref{tab:static_analysis_results}, ciascun strumento ha dimostrato punti
di forza e limitazioni specifiche: CppCheck ha identificato principalmente
memory leak, Clang ha mostrato la migliore capacità di rilevamento generale segnalando
funzioni non sicure e double free, mentre Frama-C ha evidenziato use-after-free
non rilevati dagli altri strumenti. Complessivamente, nessun singolo strumento è
riuscito a identificare tutte le vulnerabilità presenti, confermando l'importanza
di utilizzare approcci complementari nell'analisi statica. I risultati "Parziale"
nella tabella indicano i warning di Clang sull'utilizzo di funzioni non sicure
come \texttt{strcpy} e \texttt{sprintf}, dal momento che l'analizzatore non fornisce
informazioni sulla vulnerabilità specifica, ma che comunque dà un'indicazione
sul fatto che il codice potrebbe essere vulnerabile.

\begin{table}[htbp]
  \centering
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \textbf{Bug/Vulnerabilità} & \textbf{Posizione}             & \textbf{CppCheck}              & \textbf{Clang}                 & \textbf{Frama-C}               \\
    \hline
    Out-of-Bounds Write        & \texttt{main.c:27, 42}         & \cellcolor{red!20}Non Rilevato & \cellcolor{yellow!20}Parziale  & \cellcolor{red!20}Non Rilevato \\
    \hline
    Use After Free             & \texttt{main.c:127}            & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato & \cellcolor{green!20}Rilevato   \\
    \hline
    Memory Leak                & \texttt{utils.c:14-18}         & \cellcolor{green!20}Rilevato   & \cellcolor{green!20}Rilevato   & \cellcolor{red!20}Non Rilevato \\
    \hline
    Out-of-Bounds Read         & \texttt{utils.c:56}            & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato \\
    \hline
    Dangling Pointer           & \texttt{utils.c:72-79}         & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato \\
    \hline
    Buffer Overflow            & \texttt{tracker\_core.c:14,18} & \cellcolor{red!20}Non Rilevato & \cellcolor{yellow!20}Parziale  & \cellcolor{red!20}Non Rilevato \\
    \hline
    Double Free                & \texttt{tracker\_core.c:45}    & \cellcolor{red!20}Non Rilevato & \cellcolor{green!20}Rilevato   & \cellcolor{red!20}Non Rilevato \\
    \hline
    Dangling Pointer           & \texttt{tracker\_core.c:56}    & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato \\
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:81}    & \cellcolor{red!20}Non Rilevato & \cellcolor{yellow!20}Parziale  & \cellcolor{red!20}Non Rilevato \\
    \hline
    Use After Free             & \texttt{tracker\_core.c:161}   & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato & \cellcolor{red!20}Non Rilevato \\
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:194}   & \cellcolor{red!20}Non Rilevato & \cellcolor{yellow!20}Parziale  & \cellcolor{red!20}Non Rilevato \\
    \hline
    Out-of-Bounds Write        & \texttt{tracker\_core.c:216}   & \cellcolor{red!20}Non Rilevato & \cellcolor{yellow!20}Parziale  & \cellcolor{red!20}Non Rilevato \\
    \hline
  \end{tabular}
  \caption{Risultati dell'Analisi Statica}
  \label{tab:static_analysis_results}
\end{table}

\subsection*{Analisi dinamica}
Dopo aver analizzato il codice sorgente, la fase successiva è osservare il
comportamento del programma durante l'esecuzione tramite l'analisi dinamica.

Seguendo criteri simili a quelli utilizzati per la selezione degli strumenti di
analisi statica, sono stati scelti due strumenti di analisi dinamica, entrambi
già citati nella \autoref{sec:analisi-dinamica}:
\begin{itemize}
  \item \textbf{AddressSanitizer (ASan)}, uno strumento di analisi dinamica integrato
    in Clang e GCC, progettato per rilevare errori di memoria come buffer
    overflow, use-after-free e memory leak

  \item \textbf{Valgrind}, un framework di analisi dinamica che fornisce diversi
    strumenti per il rilevamento di errori di memoria, come memory leak, buffer overflow
    e use-after-free, grazie al suo strumento \texttt{memcheck}
\end{itemize}

\noindent
Poiché entrambi gli strumenti di analisi dinamica dipendono strettamente dagli
input forniti al programma durante l'esecuzione e richiedono scenari specifici
per attivare le diverse vulnerabilità, sono stati testati solamente tre casi d'uso
mirati che permettono agli analizzatori di rilevare le seguenti vulnerabilità:
\begin{itemize}
  \item \textbf{Buffer Overflow} (\texttt{tracker\_core.c:14,18}), quando il la
    lunghezza del percorso del file di log o della directory monitorata supera
    il limite di 255 caratteri

  \item \textbf{Use After Free} (\texttt{file\_tracker.c:161}), quando il
    programma prova a stampare il nome di un file eliminato dalla directory
    monitorata dopo aver liberato la memoria allocata per il nome del file

  \item \textbf{Double Free} (\texttt{tracker\_core.c:45}), quando il programma
    libera due volte la memoria allocata per la stringa del percorso della
    directory
\end{itemize}

\subsubsection*{\small AddressSanitizer\footnote{Sito: \url{https://github.com/google/sanitizers/wiki/AddressSanitizer}}}
AddressSanitizer, come già menzionato nel~\autoref{cha:sdlc}, non si limita ad agire
sul binario compilato, ma richiede l'accesso al codice sorgente, che verrà arricchito
con i controlli necessari prima della compilazione. Infatti, il comando utilizzato
per compilare il progetto con AddressSanitizer è il seguente:
\begin{lstlisting}[language=bash, numbers=none]
clang -fsanitize=address -g -O0 -std=c11 -o file_tracker_asan main.c tracker_core.c utils.c
\end{lstlisting}

Il comando specifica di abilitare AddressSanitizer (\texttt{-fsanitize=address}),
di includere le informazioni di debug (\texttt{-g}), di disabilitare le ottimizzazioni
(\texttt{-O0}) e di utilizzare lo standard C11 (\texttt{-std=c11}).

Dopo la compilazione, il programma può essere eseguito in cerca di vulnerabilità
o bug. Nello specifico, per testare le vulnerabilità selezionate, è necessaria la
creazione di contesti specifici. Di seguito sono riportati i comandi utilizzati
per l'impostazione di ciascun contesto, in base alla vulnerabilità da testare:
\begin{itemize}
  \item \textbf{Buffer Overflow}: per testare il buffer overflow, è necessario
    fornire un percorso di directory o di file di log che superi i 255 caratteri.
    Dal momento che il tracker controlla l'esistenza della directory monitorata,
    è necessario creare delle directory "a cascata" per raggiungere il limite
    imposto di 255 caratteri. Per riproducibilità, i comandi utilizzati sono i
    seguenti: \begin{lstlisting}[language=bash, numbers=none]
# creazione della directory
mkdir -p $(printf 'asan/asan1/asan2/%.0s' {1..15}) # crea 45 directory annidate
# esecuzione del tracker con un percorso di directory lungo
./file_tracker_asan ./$(printf 'asan/asan1/asan2/%.0s' {1..15})
# oppure con un file di log nella directory appena creata
./file_tracker_asan ./ -l ./$(printf 'asan/asan1/asan2/%.0s' {1..15})logfile.log
    \end{lstlisting}

  \item \textbf{Use After Free}: per testare l'use-after-free, è sufficiente
    creare una directory e un file, eseguire il tracker e infine eliminare il file:
    \begin{lstlisting}[language=bash, numbers=none]
# creazione della directory e del file
mkdir asan && touch ./asan/asan.txt
# esecuzione del tracker per monitorare la directory ./asan/
./file_tracker_asan ./asan/
    \end{lstlisting}

  \item \textbf{Double Free}: per quanto riguarda il double free, il processo è
    ancora più semplice, poiché è sufficiente eseguire il tracker su una directory
    arbitraria e poi terminare il programma premendo \texttt{Ctrl+C} per forzare
    la chiusura: \begin{lstlisting}[language=bash, numbers=none]
# esecuzione del tracker su una directory arbitraria
./file_tracker_asan ./asan/
# terminazione del programma con Ctrl+C
\end{lstlisting}
    In generale, il double free si verifica ogni volta che il programma termina
    grazie ad un segnale \texttt{SIGINT} (come \texttt{Ctrl+C}).
\end{itemize}

\noindent
Riproducendo questi tre scenari, AddressSanitizer è stato in grado di rilevare
tutte e tre le vulnerabilità, producendo output troppo estesi per essere riportati
qui, ma che possono essere trovati nella repository GitHub del progetto. È comunque
utile riportare delle considerazioni sugli output generati da AddressSanitizer:
\begin{itemize}
  \item \textbf{Localizzazione delle vulnerabilità}: AddressSanitizer fornisce informazioni
    dettagliate sulla posizione esatta della vulnerabilità nel codice, indicando
    il file e la riga specifica in cui si verifica il problema. Questo è molto utile
    per la correzione rapida e mirata.

  \item \textbf{Classificazione delle vulnerabilità}: per ogni vulnerabilità rilevata,
    ASan fornisce una nomenclatura chiara del tipo di problema (es. "heap-buffer-overflow",
    "attemting double free", ...) che aiuta a comprendere immediatamente la natura
    del bug.

  \item \textbf{Stack trace}: per ogni vulnerabilità rilevata, AddressSanitizer
    fornisce un traceback completo dello stack delle chiamate, mostrando la sequenza
    di funzioni che ha portato al problema.

  \item \textbf{Informazioni sulla memoria}: l'output include dettagli tecnici sulla
    regione di memoria coinvolta, come l'indirizzo specifico, la dimensione del blocco
    allocato e lo stato della memoria (freed, allocated, etc.).
\end{itemize}