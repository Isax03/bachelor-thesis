  \section{Tipi di vulnerabilità e casi reali}
  \label{sec:vulnerability_types}

  Secondo la tassonomia proposta da OpenSSF~\cite{memory_safety_continuum_definition},
  che rispecchia le definizioni più comunemente accettate, i bug che compromettono
  la memory safety possono essere classificati in tre macro-categorie. Ognuna di
  queste categorie rappresenta una diversa modalità con cui un programma può
  accedere in modo errato alla memoria.

  Di seguito vengono illustrate le principali categorie di vulnerabilità relative
  alla memory safety, accompagnate da esempi concreti che ne evidenziano l'impatto
  sulla sicurezza dei sistemi.

  \paragraph{Accessi fuori dai limiti (Out-of-bounds)}
  \label{sec:oob}

  Si verificano quando un programma legge o scrive al di fuori dei limiti di un buffer,
  un array o una struttura dati. Questi bug violano l'isolamento spaziale della memoria
  e possono corrompere dati o consentire esecuzione arbitraria di codice.

  \begin{itemize}
    \item \textbf{Buffer overflow}: scrittura oltre la fine di un buffer.

    \item \textbf{Buffer underflow}: scrittura prima dell'inizio del buffer.

    \item \textbf{Index out-of-bounds}: accesso a un indice non valido in array o vettori.
  \end{itemize}

  \textbf{Caso reale: HeartBleed} -- Nel 2014, una vulnerabilità di tipo out-of-bounds
  read nella libreria OpenSSL ha causato una massiccia fuga di dati sensibili da server
  web in tutto il mondo. L'errore, situato nell'estensione TLS Heartbeat,
  permetteva a un client malintenzionato di inviare una richiesta in cui
  dichiarava una lunghezza del messaggio superiore a quella effettivamente inviata.
  Il server, invece di verificare che la lunghezza dichiarata corrispondesse ai
  dati ricevuti, rispondeva restituendo il proprio messaggio originale più dati aggiuntivi
  presi casualmente dalla propria memoria interna. Questi dati potevano includere
  informazioni sensibili come chiavi private, credenziali o altri dati critici.~\cite{heartbleed}.

  \paragraph{Accessi all'heap dopo il rilascio (Use-after-free)}
  \label{sec:uaf}

  Consistono nell'accesso a una regione di memoria precedentemente deallocata. Questa
  memoria può essere riutilizzata da altri oggetti, portando a comportamenti
  imprevedibili e alla lettura di dati sensibili.

  \begin{itemize}
    \item \textbf{Dangling pointer}: puntatore che fa riferimento a un'area già liberata
      e non più valida.

    \item \textbf{Double free}: tentativo di liberare due volte la stessa area di memoria,
      spesso legato ad esecuzioni multi-thread che portano a concorrenza di accessi.
  \end{itemize}

  \textbf{Caso reale: WebAudio in Chrome} -- Nel 2020 è stata scoperta una vulnerabilità
  use-after-free nel motore WebAudio di Google Chrome, legata alla gestione
  asincrona degli oggetti \texttt{AudioBufferSourceNode}. Un attaccante poteva
  manipolare il flusso di esecuzione creando condizioni di race tra thread audio e
  main thread, portando a un accesso a memoria già liberata. La vulnerabilità è
  stata sfruttata per ottenere l'esecuzione di codice arbitrario e dimostra come
  errori apparentemente semplici possano essere concatenati in exploit complessi e
  reali~\cite{webaudio_uaf}.

  \paragraph{Accessi alla memoria non inizializzata o non allocata}
  \label{sec:invalid_access}

  Questa categoria comprende l'uso di puntatori non inizializzati, nulli o che puntano
  a zone mai allocate. Tali accessi portano a crash o, in alcuni casi, a
  esecuzione di codice non controllato.

  \begin{itemize}
    \item \textbf{Null dereference}: dereferenziazione di un puntatore nullo.

    \item \textbf{Uninitialized memory access}: utilizzo di variabili o strutture prima
      della loro inizializzazione.

    \item \textbf{Wild pointer}: puntatori con valore casuale o invalido, spesso
      derivanti da mancata inizializzazione.
  \end{itemize}

  \textbf{Caso reale: Linux Kernel (versioni 2.6.x)} -- Nel 2009, è stato scoperto
  un bug di null pointer dereference nel kernel Linux. La vulnerabilità prevedeva la
  mancata inizializzazione dei puntatori a funzione in alcune strutture. Questo
  permetteva a un eventuale attaccante di scatenare una dereferenziazione di
  puntatori nulli, portando a esecuzione arbitraria di codice inserito nella pagina
  con indirizzo 0 (NULL), per raggiungere privilegi di root e avere accesso
  completo al sistema.~\cite{null_pointer_dereference_linux}

  \paragraph{Memory Leaks}
  \label{sec:memory_leaks} Si verificano quando un programma alloca dinamicamente memoria
  senza rilasciarla correttamente, causando un accumulo progressivo di aree
  inutilizzate che rimangono occupate per tutta la durata dell'esecuzione. Poiché i
  memory leak non comportano accessi non autorizzati o errati alla memoria, non
  sono generalmente considerati come bug relativi alla memory safety, ma possono comunque
  compromettere la stabilità e la sicurezza di un sistema.

  \subsection{Classificazione CWE}
  Oltre alla tassonomia di OpenSSF, la Common Weakness Enumeration (CWE) fornisce
  una panoramica più ampia delle vulnerabilità software.

  La CWE è un catalogo sviluppato dalla comunità informatica per identificare e
  classificare le debolezze nei sistemi software. Il sito offre diversi elenchi di
  vulnerabilità raggruppate per contesto, tra cui la categoria CWE-1399\footnote{Comprehensive
  Categorization: Memory Safety,~\url{https://cwe.mitre.org/data/definitions/1399.html}}
  che raccoglie le vulnerabilità legate alla memoria.

  Per ogni debolezza è fornita una descrizione, relazioni con altre debolezze e
  collegamenti a best practice dettate da enti come OWASP e SEI CERT, menzionati più
  avanti nella~\autoref{sec:best-practices-codice}. Alcune vulnerabilità sono poi
  associate anche ai relativi vettori d'attacco a cui sono soggette.