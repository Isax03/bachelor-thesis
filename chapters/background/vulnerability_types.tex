\section{Tipi di vulnerabilità e casi reali}
\label{sec:vulnerability_types}

Secondo la tassonomia proposta da OpenSSF\cite{memory_safety_continuum_definition},
che rispecchia le definizioni più comunemente accettate, i bug che compromettono
la memory safety possono essere classificati in tre macro-categorie. Ognuna di queste
categorie rappresenta una diversa modalità con cui un programma può accedere in modo
errato alla memoria.

Di seguito vengono illustrate le principali categorie di vulnerabilità relative alla
memory safety, accompagnate da esempi concreti che ne evidenziano l'impatto
sulla sicurezza dei sistemi.

\paragraph{Accessi fuori dai limiti (Out-of-bounds)}
\label{sec:oob}

Comprendono tutte le situazioni in cui un programma legge o scrive al di fuori
dei limiti di un buffer, array o struttura dati. Questi bug violano l'isolamento
spaziale della memoria e possono corrompere dati o consentire esecuzione
arbitraria di codice.

\begin{itemize}
  \item \textbf{Buffer overflow}: scrittura oltre la fine di un buffer.

  \item \textbf{Buffer underflow}: scrittura prima dell'inizio del buffer.

  \item \textbf{Index out-of-bounds}: accesso a un indice non valido in array o vettori.
\end{itemize}

\textbf{Caso reale: HeartBleed} — Nel 2014, una vulnerabilità di tipo out-of-bounds
read nella libreria OpenSSL ha causato una massiccia fuga di dati sensibili da server
web in tutto il mondo. L'errore, situato nell'estensione TLS Heartbeat,
permetteva a un client malintenzionato di richiedere una risposta più lunga del
payload effettivamente inviato. Il server, non verificando correttamente la
lunghezza del messaggio, rispondeva con il contenuto originale più porzioni casuali
di memoria interna, potenzialmente contenenti chiavi private, credenziali o altri
dati critici\cite{heartbleed}.

\paragraph{Accessi all'heap dopo il rilascio (Use-after-free)}
\label{sec:uaf}

Si verificano quando un programma accede a una regione di memoria
precedentemente deallocata. Questa memoria può essere riutilizzata da altri oggetti,
portando a comportamenti imprevedibili come crash e alla lettura di dati
sensibili o di norma non accessibili.

\begin{itemize}
  \item \textbf{Dangling pointer}: puntatore che fa riferimento a un'area già liberata
    e non più valida.

  \item \textbf{Double free}: tentativo di liberare due volte la stessa area di memoria,
    spesso sfruttabile per corrompere lo heap.
\end{itemize}

\textbf{Caso reale: WebAudio in Chrome} — Nel 2020 è stata scoperta una
vulnerabilità use-after-free nel motore WebAudio di Google Chrome, legata alla gestione
asincrona degli oggetti \texttt{AudioBufferSourceNode}. Un attaccante poteva manipolare
il flusso di esecuzione creando condizioni di race tra thread audio e main thread,
portando a un accesso a memoria già liberata. La vulnerabilità è stata sfruttata
per ottenere l'esecuzione di codice arbitrario e dimostra come errori apparentemente
semplici possano essere concatenati in exploit complessi e reali\cite{webaudio_uaf}.

\paragraph{Accessi alla memoria non inizializzata o non allocata}
\label{sec:invalid_access}

Questa categoria comprende l'uso di puntatori non inizializzati, nulli o che puntano
a zone mai allocate. Tali accessi portano a crash o, in alcuni casi, a
esecuzione di codice non controllato.

\begin{itemize}
  \item \textbf{NULL dereference}: dereferenziazione di un puntatore nullo.

  \item \textbf{Uninitialized memory access}: utilizzo di variabili o strutture prima
    della loro inizializzazione.

  \item \textbf{Wild pointer}: puntatori con valore casuale o invalido, spesso
    derivanti da mancata inizializzazione.
\end{itemize}

\textbf{Caso reale: Linux Kernel (versioni 2.6.x)} — Nel 2009, è stato scoperto un
bug di NULL pointer dereference nel kernel Linux. La vulnerabilità prevedeva la
mancata inizializzazione dei puntatori a funzione in alcune strutture. Questo permetteva
a un eventuale attaccante di scatenare una dereferenziazione di puntatori nulli,
portando a esecuzione arbitraria di codice inserito nella pagina con indirizzo 0
(NULL), per raggiungere privilegi di root e avere accesso completo al sistema.\cite{null_pointer_dereference_linux}

\paragraph{Memory Leaks}
\label{sec:memory_leaks} Si verificano quando un programma alloca memoria ma non
la rilascia correttamente, portando a un graduale esaurimento delle risorse
disponibili. Sebbene non vengano spesso considerati come bug \textit{memory
unsafe}, in quanto meno critici di altre vulnerabilità, i memory leak possono
causare denial-of-service o degradazione delle prestazioni in sistemi long-running.

\subsection{Classificazione CWE}
Oltre alla tassonomia di OpenSSF, la Common Weakness Enumeration (CWE) fornisce
una panoramica più ampia delle vulnerabilità software.

La CWE è un catalogo sviluppato dalla comunità informatica per identificare e
classificare le debolezze nei sistemi software. Il sito offre diversi elenchi di
vulnerabilità raggruppate per contesto, tra cui la categoria CWE-1399\footnote{Comprehensive
Categorization: Memory Safety,~\url{https://cwe.mitre.org/data/definitions/1399.html}}
che raccoglie le vulnerabilità legate alla memoria.

Per ogni debolezza è fornita una descrizione, relazioni con altre debolezze e collegamenti
a best practices dettate da enti come OWASP e SEI CERT, menzionati più avanti
nella \autoref{sec:best-practices-codice}. Alcune vulnerabilità sono poi associate
anche ai relativi vettori d'attacco a cui sono soggette.