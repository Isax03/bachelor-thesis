\section{Definizione di Memory Safety}
\label{sec:memory_safety}

Il concetto di memory safety non dispone di una definizione formale univoca,
generalmente riconosciuta da tutta la comunità scientifica. In letteratura si trovano,
per la maggior parte, definizioni di carattere più pratico, che si concentrano
sull'assenza di determinati tipi di bug o comportamenti indesiderati legati alla
gestione della memoria.

Un'eccezione significativa è rappresentata dall'articolo \textit{The Meaning of
Memory Safety}\cite{meaning_memory_safety}, che si pone l'obiettivo di formalizzare
rigorosamente il concetto, supportandolo con teoremi e dimostrazioni.

\vspace{0.5em}
Di seguito, verranno presentate sia la definizione formale che quella pratica e intuitiva
di memory safety, per fornire una visione completa del concetto e delle sue
implicazioni.

\subsection{Definizione formale}
\label{sec:formal_definition}

L'articolo citato\cite{meaning_memory_safety} propone una formalizzazione
rigorosa della memory safety attraverso un framework matematico basato su
semantica operazionale e strutture formali per ragionare sulla sicurezza della
memoria in modo verificabile.

Nel modello proposto, un programma è considerato \textit{memory safe} se durante
la sua esecuzione preserva le seguenti proprietà fondamentali:
\begin{enumerate}
  \item \textbf{Isolamento spaziale e temporale}:
    \begin{itemize}
      \item Le operazioni su una regione di memoria non influenzano dati al di fuori
        del proprio ``footprint'' (porzione accessibile).

      \item I \textit{Frame Theorems} (Sezione 3) garantiscono che l'estensione
        dello heap iniziale con blocchi non raggiungibili non alteri il
        comportamento del programma.
    \end{itemize}

  \item \textbf{Non-interferenza} (Corollario 1):
    \begin{itemize}
      \item La memoria non raggiungibile non può modificare né essere modificata
        dall'esecuzione. Ciò assicura sia \textit{integrità} (impossibilità di
        alterare dati isolati) sia \textit{segretezza} (impossibilità di dedurne
        l'esistenza).
    \end{itemize}

  \item \textbf{Contenimento degli errori}:
    \begin{itemize}
      \item Accessi illegali (es. dereferenziazione di puntatori invalidi)
        terminano l'esecuzione in modo prevedibile con un errore esplicito, evitando
        comportamenti indefiniti.
    \end{itemize}
\end{enumerate}

Questo modello consente di dimostrare proprietà come la protezione tra moduli e
l'assenza di comportamenti indefiniti. Conseguentemente, esso fornisce anche un
solido framework matematico per specificare e dimostrare le garanzie di
sicurezza implementate da un sistema (come proprietà del type system o del memory
model). Tale formalizzazione guida inoltre lo sviluppo di strumenti verificati per
l'enforcement della memory safety, come i monitor hardware/software descritti
nel paper (ad esempio PUMP, Sezione 5).

Tuttavia, questa definizione si basa su ipotesi idealizzate, come memoria illimitata,
assenza di aritmetica sui puntatori o di cast a interi, che lo rendono parzialmente
distante dai linguaggi e dagli ambienti reali (Sezione 4). Per questo motivo una
definizione più intuitiva e pratica è necessaria per comprendere il concetto di
memory safety in contesti reali.

\subsection{Definizione pratica}
\label{sec:practical_definition}

Dal punto di vista pratico, la memory safety viene comunemente intesa come la
capacità di un programma di evitare comportamenti errati o vulnerabilità legate
alla gestione della memoria dinamica.

In particolare, si riferisce alla prevenzione di errori come buffer overflows,
use-after-free e dangling pointers, che possono compromettere l'integrità o la sicurezza
del software. Una panoramica di queste vulnerabilità sarà fornita nella \autoref{sec:vulnerability_types}.

Sebbene non costituisca una fonte accademica formale, Wikipedia\cite{wikipedia_definition}
riflette questa visione diffusa, definendo la memory safety come \textit{"lo stato
di protezione da vari bug nel software e vulnerabilità nella sicurezza, quando
si ha a che fare con accessi in memoria"}. Questa formulazione, pur semplificata,
è in linea con numerosi articoli tecnici e documenti divulgativi che descrivono la
memory safety attraverso l'eliminazione di specifiche classi di bug piuttosto che
tramite una definizione formale.

% Memory Safety Continuum %
\subsection{Memory safety come spettro continuo}
\label{sec:continuum_definition}

Sebbene le definizioni formale e pratica adottino approcci diversi, entrambe sottintendono
che la memory safety non sia una proprietà assoluta o binaria, ma una condizione
che può essere raggiunta in misura variabile.

Questa idea viene esplicitamente sviluppata nell'articolo \textit{The Memory
Safety Continuum}\cite{memory_safety_continuum}, pubblicato dalla OpenSSF, che
propone di interpretare la memory safety come uno spettro continuo. In tale visione,
sistemi e linguaggi possono offrire livelli differenti di protezione, a seconda delle
garanzie fornite e delle mitigazioni adottate.

Questo approccio sottolinea come la memory safety possa essere rafforzata progressivamente,
piuttosto che garantita in modo assoluto.