\section{Pianificazione, Analisi dei Requisiti e Design}
\label{sec:planning_requirements_design}

Le fasi preliminari del \textit{Software Development Life Cycle} (SDLC)
comprendono l'analisi dei requisiti, la pianificazione e il design del software.
Sebbene queste attività non prevedano ancora la scrittura effettiva del codice, rivestono
un ruolo cruciale nella definizione delle proprietà di sicurezza dell'intero sistema,
incluse le garanzie di \textit{memory safety}.

Una corretta impostazione in queste fasi consente di identificare precocemente i
rischi legati all'uso della memoria e di predisporre adeguate strategie di mitigazione.
Ad esempio, in un progetto che prevede l'implementazione di algoritmi crittografici,
è fondamentale orientare le scelte tecniche (come linguaggi e librerie) verso
strumenti che riducano al minimo la possibilità di errori di memoria. Una gestione
errata in questo ambito può esporre l'applicazione a vulnerabilità gravi, come
la possibilità di decrittare dati sensibili o di compromettere l'integrità del
sistema.

In particolare, già in fase di progettazione è possibile (e raccomandabile) condurre
un'analisi dei requisiti di sicurezza, esplicitando obiettivi orientati alla
\textit{memory safety}. Analogamente, durante la fase di pianificazione, è utile
prevedere misure difensive trasversali all'intero ciclo di vita, come l'uso di ambienti
\textit{sandbox} durante il deployment per limitare i danni derivanti da
eventuali vulnerabilità di memoria. Questi requisiti e decisioni guideranno poi tutte
le fasi successive dello sviluppo.

\subsection{Definizione di roadmaps}
\label{sec:roadmap} Un'attività essenziale ma spesso trascurata è la definizione
di \textit{roadmaps} da parte delle organizzazioni. Delineare una chiara strategia
di sviluppo e di adozione delle tecnologie è uno dei primi passi per entrare nell'ottica
di un approccio \textit{memory safe}.

In quest'ottica, la CyberSecurity and Infrastructure Security Agency (CISA), in
collaborazione con agenzie internazionali, ha pubblicato il documento \textit{The
Case for Memory Safe Roadmaps}\cite{memory_safe_roadmaps}. Questo documento
fornisce linee guida per i produttori di software su come creare e pubblicare
roadmap per la transizione verso linguaggi di programmazione che garantiscano la
sicurezza della memoria. Inoltre, viene fornita una serie di mitigazioni
applicabili a linguaggi non \textit{memory safe}.

In particolare, secondo l'articolo, una roadmap efficace per la \textit{memory
safety} dovrebbe includere:

\begin{itemize}
  \item \textbf{Fasi definite con date e risultati attesi}: spezzare il processo
    di transizione in fasi chiare e più piccole come:
    \begin{itemize}
      \item Valutazione dei linguaggi \textit{memory safe}

      \item Scrittura di un nuovo componente utilizzando un linguaggio \textit{memory
        safe "by default"} o incorporazione di un linguaggio \textit{memory safe}
        in un componente esistente per testare l'efficacia

      \item \textit{Threat modeling} per identificare il codice memory unsafe
        più pericoloso

      \item Refactoring del codice memory unsafe
    \end{itemize}

  \item \textbf{Scadenza per l'uso esclusivo di linguaggi memory safe nei nuovi
    sistemi}: stabilire una data a partire dalla quale tutto il nuovo codice sarà
    scritto in un linguaggio memory safe.

  \item \textbf{Piano di formazione interna e integrazione nei workflow}: prevedere
    tempo e risorse per formare i team su linguaggi \textit{memory safe}, debugging,
    integrazione nei processi di build e controllo della qualità.

  \item \textbf{Gestione delle dipendenze esterne (es. librerie C/C++)}: documentare
    una strategia per gestire le dipendenze legacy, in particolare librerie open
    source scritte in C/C++.

  \item \textbf{Piano di trasparenza}: aggiornamenti periodici (es. trimestrali/semestrali)
    per comunicare progressi, sfide e miglioramenti al SDLC, e ispirare altri ad
    adottare approcci simili

  \item \textbf{Piano per il supporto ai CVE}: impegno a fornire CWE per il 100\%
    delle vulnerabilità pubblicate (CVE) e a offrire contesto tecnico utile per
    distinguere i difetti memory-unsafe da altri tipi di bug
\end{itemize}

L'adozione di tali roadmap rappresenta un passo fondamentale verso la realizzazione
di sistemi software più sicuri e resilienti, riducendo significativamente il
rischio di vulnerabilità legate alla gestione della memoria.

\subsection{Scelta del Linguaggio}
\label{sec:linguaggio}

La scelta del linguaggio di programmazione rappresenta una delle decisioni primarie
nelle fasi preliminari dello sviluppo software. Essa influenza in modo diretto
la qualità, la sicurezza e la manutenibilità del codice prodotto, ed è
particolarmente rilevante quando si vogliono prevenire vulnerabilità legate alla
\textit{memory safety}.

Sebbene linguaggi come Rust siano stati progettati con l'obiettivo esplicito di garantire
la \textit{memory safety}, non esiste una soluzione unica valida per tutti i contesti.
Ogni linguaggio presenta compromessi progettuali che ne influenzano l'idoneità
in scenari specifici.

Per esempio, C e C++ restano la scelta dominante nello sviluppo di firmware,
driver o sistemi embedded, dove è richiesto un controllo a basso livello dell'hardware
e delle risorse. Al contrario, Java e Kotlin trovano impiego in applicazioni mobili
e enterprise, grazie alla loro portabilità e al supporto dell'ecosistema JVM. Le
possibilità sono numerose, e ogni progetto potrebbe richiedere una combinazione
diversa di criteri funzionali e non funzionali.

Oltre alle caratteristiche tecniche, la scelta del linguaggio dipende spesso anche
da fattori pragmatici come il know-how del team, la disponibilità di tool e
librerie, i vincoli di tempo, o l'integrazione con sistemi esistenti e/o legacy.
Infatti, vale la pena sottolineare che, sebbene la scelta del linguaggio sia cruciale,
non è sempre possibile effettuarla. In alcuni casi, il linguaggio è vincolato
dalla codebase esistente, da requisiti di interoperabilità o da standard di settore.
Per tali situazioni, questa sezione della tesi può essere poco utile nella pratica,
ma può comunque fornire spunti per migliorare la sicurezza della memoria e dare
una panoramica dei linguaggi \textit{memory safe} più diffusi.

Per offrire una panoramica concreta, viene di seguito riportata la
\autoref{tab:linguaggi_memory_safety}, sviluppata in collaborazione con i ricercatori
del Centro per la CyberSecurity di FBK, che riassume alcune proprietà rilevanti
per la \textit{memory safety}, mettendo a confronto alcuni linguaggi secondo
criteri come il controllo automatico dei limiti di accesso, la gestione dei puntatori
nulli, la sicurezza di tipo e altri aspetti chiave.

\small
\setlength{\tabcolsep}{4pt}
\begin{table}[H]
  \centering
  \begin{tabular}{l|c|c|c|c|c|c|}
    \multicolumn{1}{l}{}         & \textbf{C/C++}                & \textbf{Java}                 & \textbf{Kotlin}               & \textbf{Python}               & \textbf{Rust}                       & \textbf{Go}               \\
    \hline
    \textbf{Bounds Check}        & \cellcolor{red!20}No          & \cellcolor{green!20}Sì        & \cellcolor{green!20}Sì        & \cellcolor{green!20}Sì        & \cellcolor{green!20}Sì              & \cellcolor{green!20}Sì    \\
    \textbf{Null Safety}         & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{green!20}Sì        & \cellcolor{yellow!20}Parziale & \cellcolor{green!20}Sì              & \cellcolor{green!20}Sì    \\
    \textbf{Ownership/Borrowing} & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{green!20}Sì              & \cellcolor{red!20}No      \\
    \textbf{Type Safety}         & \cellcolor{yellow!20}Parziale & \cellcolor{yellow!20}Parziale & \cellcolor{yellow!20}Parziale & \cellcolor{green!20}Sì        & \cellcolor{green!20}Sì              & \cellcolor{green!20}Sì    \\
    \textbf{Memory Zeroization}  & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{red!20}No          & \cellcolor{green!20}Sì\footnotemark & \cellcolor{red!20}No      \\
    \textbf{Memory Integrity}    & \cellcolor{red!20}No          & \cellcolor{yellow!20}Parziale & \cellcolor{yellow!20}Parziale & \cellcolor{red!20}No          & \cellcolor{green!20}Sì              & \cellcolor{green!20}Sì    \\
    \textbf{Difficulty}          & \cellcolor{red!20}Alta        & \cellcolor{yellow!20}Media    & \cellcolor{yellow!20}Media    & \cellcolor{green!20}Bassa     & \cellcolor{red!20}Alta              & \cellcolor{green!20}Bassa \\
    \hline
  \end{tabular}
  \caption{Confronto delle caratteristiche legate alla \textit{memory safety} tra
  linguaggi di programmazione}
  \label{tab:linguaggi_memory_safety}
\end{table}

\footnotetext{Supportata tramite il crate \texttt{zeroize}, mantenuto dal team
\texttt{RustCrypto} e ampiamente usato per la gestione sicura di dati sensibili.}

Come si può notare dalla tabella, i linguaggi più recenti come Rust e Go offrono
una maggiore sicurezza rispetto a linguaggi più datati come C/C++. Java, Kotlin e
Python si collocano in una posizione intermedia: sono comunemente considerati
\textit{memory safe by default} grazie al garbage collector, ma hanno meno
funzionalità avanzate che rafforzano la sicurezza della memoria.

\paragraph{Memory Zeroization}
Un aspetto spesso trascurato ma rilevante è il supporto alla \textbf{memory
zeroization}, ovvero la capacità del linguaggio o delle librerie di pulire automaticamente
aree di memoria contenenti dati sensibili una volta terminato il loro utilizzo.
Questo è particolarmente importante in contesti crittografici o in applicazioni
che gestiscono credenziali e segreti in chiaro.

\paragraph{Learning Curve}
Altra caratteristica fondamentale da considerare è la curva di apprendimento del
linguaggio, che può impattare significativamente sui tempi di adozione e sul
rischio di introdurre bug nei primi cicli di sviluppo. Sebbene si tratti di un aspetto
soggettivo, alcune stime empiriche\cite{learning_curves} suggeriscono che linguaggi
come Python e Go siano più accessibili rispetto a Rust o C++, che richiedono una
maggiore familiarità con i concetti di basso livello e di gestione esplicita
delle risorse.

\paragraph{Librerie}
Infine, è importante ricordare che la sola scelta del linguaggio non garantisce
la sicurezza della memoria: l'ecosistema di \textit{librerie} gioca un ruolo
altrettanto determinante. Si raccomanda pertanto di valutare la maturità, la
qualità del codice, e la presenza di audit di sicurezza nelle librerie esterne utilizzate,
specialmente se implementate in linguaggi memory-unsafe (es. librerie Python
scritte in C) o non pienamente compatibili con il modello di sicurezza adottato dal
progetto.

\newpage